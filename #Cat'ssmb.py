#!/usr/bin/env python3
"""
Ultra Mario 2D Bros — Complete 32-level (1-1 → 8-4) Pygame platformer
Team Flames / Samsoft / Flames Co.
Single-file implementation with authentic SMB1-style physics & gameplay.
"""

import pygame, sys, random, math

pygame.init()
pygame.mixer.init(frequency=22050, size=-16, channels=2, buffer=512)

# ============================================================
# DISPLAY
# ============================================================
TILE  = 16
SCALE = 3
T     = TILE * SCALE          # 48
SCR_W = 256 * SCALE           # 768
SCR_H = 240 * SCALE           # 720
FPS   = 60

screen = pygame.display.set_mode((SCR_W, SCR_H))
pygame.display.set_caption("Ultra Mario 2D Bros")
clock  = pygame.time.Clock()

# ============================================================
# COLORS  (NES-inspired palette)
# ============================================================
C_SKY       = (107, 140, 255)
C_SKY_NIGHT = (0, 0, 0)
C_UNDER_BG  = (0, 0, 0)
C_CASTLE_BG = (0, 0, 0)
C_ATH_BG    = (107, 170, 255)

C_GROUND    = (200, 76, 12)
C_GROUND2   = (148, 148, 148)
C_BRICK     = (164, 74, 0)
C_UBRICK    = (60, 60, 168)
C_CBRICK    = (168, 88, 40)
C_QUESTION  = (252, 152, 56)
C_QMARK     = (180, 100, 0)
C_PIPE      = (0, 168, 0)
C_PIPE_D    = (0, 120, 0)
C_PIPE_LIP  = (0, 200, 0)
C_MARIO_R   = (216, 40, 0)
C_MARIO_S   = (252, 152, 56)
C_MARIO_BROWN = (128, 56, 0)
C_GOOMBA    = (112, 28, 0)
C_GOOMBA_L  = (160, 50, 0)
C_KOOPA_G   = (0, 168, 0)
C_KOOPA_S   = (252, 216, 88)
C_BLACK     = (0, 0, 0)
C_WHITE     = (255, 255, 255)
C_GRAY      = (168, 168, 168)
C_LAVA      = (228, 56, 0)
C_LAVA2     = (252, 128, 0)
C_FLAG_G    = (0, 200, 0)
C_CASTLE_W  = (120, 120, 120)
C_MENU_BG   = (0, 0, 0)
C_TITLE     = (252, 152, 56)
C_SEL       = (255, 255, 255)
C_UNSEL     = (168, 168, 168)
C_COIN      = (252, 200, 56)
C_HUD       = (255, 255, 255)
C_STAR_Y    = (252, 252, 0)
C_FIRE_R    = (228, 56, 0)
C_FIRE_O    = (252, 160, 68)
C_CLOUD     = (252, 252, 252)
C_BUSH      = (0, 168, 0)
C_BUSH_D    = (0, 120, 0)
C_HILL      = (0, 168, 0)
C_HILL_D    = (0, 120, 0)

# ============================================================
# PHYSICS  (SMB1-authentic)
# ============================================================
GRAVITY   = 0.55
FRICTION  = 0.82
ACCEL     = 0.45
JUMP      = -10.5
MAX_SPD   = 4.0
RUN_SPD   = 6.0
BOUNCE    = -6
ENEMY_SPD = 0.8
FIREBALL_SPD = 5.0

# ============================================================
# LEVEL TYPES
# ============================================================
LT_OVER     = 0
LT_UNDER    = 1
LT_ATHLETIC = 2
LT_CASTLE   = 3

# ============================================================
# LEVEL DATA BUILDER
# ============================================================
def _L(t, w, g, br=None, bi=None, q=None, p=None, eg=None, ek=None,
       st=None, f=198, ceil=False, lava=None, plat=None):
    return {
        't': t, 'w': w, 'g': g,
        'br': br or [], 'bi': bi or [], 'q': q or [],
        'p': p or [], 'eg': eg or [], 'ek': ek or [],
        'st': st or [], 'f': f, 'ceil': ceil,
        'lava': lava or [], 'plat': plat or [],
    }

# ============================================================
# ALL 32 LEVELS  (Worlds 1-1 through 8-4)
# ============================================================
LEVELS = [
    # ===================== WORLD 1 =====================
    # 1-1: Classic overworld
    _L(LT_OVER, 212,
       g=[(0,68),(71,86),(89,153),(156,211)],
       br=[(20,24,9),(77,79,5),(91,92,9),(100,101,9),(118,120,9),
           (128,131,9),(168,171,9)],
       bi=[(80,9),(94,9),(169,5),(170,5)],
       q=[(16,9),(21,9),(22,5),(23,9),(78,9),(94,5),(106,9),(109,9),
          (109,5),(112,9),(129,9),(130,9),(170,9)],
       p=[(28,2),(38,3),(46,4),(57,4),(163,2),(179,2)],
       eg=[22,40,51,52,80,82,97,98,114,115,124,125,174,175],
       ek=[107],
       st=[(134,4,1),(140,4,1),(148,8,1),(181,8,1)],
       f=198),

    # 1-2: Underground
    _L(LT_UNDER, 200,
       g=[(0,14),(16,45),(48,72),(75,120),(123,160),(163,199)],
       br=[(18,22,5),(18,22,9),(30,35,5),(55,62,9),(55,62,5),
           (80,88,9),(95,100,5),(135,142,9),(150,156,5)],
       bi=[(25,9),(26,9),(40,5),(41,5),(70,9)],
       q=[(20,9),(32,9),(33,5),(58,9),(60,5),(85,9),(97,9),(140,9)],
       p=[(44,2),(68,3),(155,2)],
       eg=[24,36,37,56,57,82,83,96,100,138,139,152,153],
       ek=[65,90],
       st=[(170,8,1)],
       f=188, ceil=True),

    # 1-3: Athletic / treetops
    _L(LT_ATHLETIC, 180,
       g=[(0,10),(165,179)],
       br=[(50,54,7),(85,88,5),(110,114,8)],
       bi=[],
       q=[(30,8),(52,4),(87,8),(112,5),(130,7)],
       p=[],
       eg=[32,55,90,115,135],
       ek=[70,100],
       st=[(158,8,1)],
       f=170,
       plat=[(12,11,5),(20,9,4),(28,11,3),(35,8,5),(42,10,4),
              (48,7,6),(58,10,4),(64,8,5),(72,11,3),(78,9,4),
              (84,6,6),(92,10,3),(98,8,5),(105,11,4),(110,9,6),
              (118,7,4),(124,10,3),(130,8,5),(138,11,4),(145,9,5),
              (152,7,4)]),

    # 1-4: Castle
    _L(LT_CASTLE, 180,
       g=[(0,20),(24,50),(54,80),(84,120),(124,179)],
       br=[(5,8,5),(15,18,9),(30,38,5),(60,68,5),(90,98,5),
           (105,110,9),(130,135,5),(145,155,5)],
       bi=[(10,9),(42,9),(72,9),(85,9)],
       q=[],
       p=[],
       eg=[15,35,36,55,65,95,96,110,140,141,150],
       ek=[],
       st=[(160,4,1)],
       f=170, ceil=True,
       lava=[(21,23),(51,53),(81,83),(121,123)]),

    # ===================== WORLD 2 =====================
    # 2-1: Overworld - more enemies
    _L(LT_OVER, 220,
       g=[(0,55),(58,95),(98,155),(158,219)],
       br=[(15,20,9),(35,40,5),(65,72,9),(85,90,5),(105,112,9),
           (130,136,5),(155,160,9),(180,186,9)],
       bi=[(22,9),(45,9),(75,5),(95,9),(115,5),(140,9)],
       q=[(17,9),(18,5),(37,9),(68,9),(70,5),(88,9),(108,9),(110,5),
          (133,9),(157,9),(183,9)],
       p=[(25,2),(48,3),(78,4),(142,3),(170,2)],
       eg=[20,30,31,60,62,80,82,100,102,120,122,145,165,167,190,192],
       ek=[50,110,160],
       st=[(195,8,1)],
       f=208),

    # 2-2: Underground
    _L(LT_UNDER, 210,
       g=[(0,35),(38,70),(73,115),(118,165),(168,209)],
       br=[(8,14,5),(8,14,9),(25,30,5),(45,52,9),(45,52,5),
           (80,88,9),(80,88,5),(100,108,5),(125,132,9),(145,152,5),
           (175,182,9)],
       bi=[(18,9),(34,5),(60,9),(95,5),(115,9),(138,9),(160,5)],
       q=[(10,9),(12,5),(28,9),(48,9),(50,5),(84,9),(86,5),
          (104,9),(128,9),(148,9),(178,9)],
       p=[(20,2),(55,3),(92,2),(135,3),(162,2)],
       eg=[15,32,33,58,59,78,82,98,100,120,125,142,155,170,175],
       ek=[42,105,150],
       st=[(188,8,1)],
       f=198, ceil=True),

    # 2-3: Athletic bridge
    _L(LT_ATHLETIC, 190,
       g=[(0,8),(175,189)],
       br=[(40,44,7),(70,74,5),(100,105,7),(130,134,5)],
       bi=[],
       q=[(25,8),(42,4),(72,8),(102,4),(132,8),(150,7)],
       p=[],
       eg=[28,45,75,105,135,155],
       ek=[60,95,125],
       st=[(165,8,1)],
       f=180,
       plat=[(10,11,6),(18,9,4),(25,11,5),(32,8,4),(38,6,8),
              (48,10,5),(55,8,4),(62,11,3),(68,6,8),(76,10,4),
              (82,8,5),(88,11,3),(95,7,4),(100,5,7),(108,10,4),
              (115,8,5),(122,11,3),(128,6,8),(136,10,4),(142,8,5),
              (148,11,3),(155,9,5),(162,7,4)]),

    # 2-4: Castle
    _L(LT_CASTLE, 190,
       g=[(0,25),(29,55),(59,85),(89,125),(129,189)],
       br=[(8,15,5),(8,15,9),(35,42,5),(65,72,5),(95,105,5),
           (95,105,9),(115,120,5),(135,145,5),(155,165,9)],
       bi=[(20,9),(48,9),(78,9),(110,9)],
       q=[],
       p=[],
       eg=[18,38,40,68,70,98,100,118,140,142,158,160],
       ek=[55,85],
       st=[(170,4,1)],
       f=180, ceil=True,
       lava=[(26,28),(56,58),(86,88),(126,128)]),

    # ===================== WORLD 3 =====================
    # 3-1: Overworld - dense enemies
    _L(LT_OVER, 225,
       g=[(0,42),(45,85),(88,140),(143,180),(183,224)],
       br=[(12,18,9),(28,34,5),(50,58,9),(70,76,5),(95,102,9),
           (115,120,5),(145,152,9),(165,170,5),(190,196,9)],
       bi=[(20,5),(38,9),(60,5),(80,9),(108,5),(125,9),(158,5)],
       q=[(14,9),(16,5),(30,9),(32,5),(54,9),(56,5),(72,9),
          (98,9),(100,5),(118,9),(148,9),(168,9),(193,9)],
       p=[(22,3),(40,4),(82,3),(128,4),(172,2)],
       eg=[16,25,26,48,50,65,68,92,94,110,112,130,135,150,155,175,
           178,195,198],
       ek=[35,75,105,145,185],
       st=[(200,8,1)],
       f=212),

    # 3-2: Overworld with platforms
    _L(LT_OVER, 215,
       g=[(0,50),(53,100),(103,158),(161,214)],
       br=[(15,22,9),(35,40,5),(60,68,9),(80,86,5),(108,115,9),
           (128,134,5),(162,168,9),(182,188,5)],
       bi=[(25,9),(45,5),(72,9),(90,5),(120,5),(140,9)],
       q=[(18,9),(20,5),(38,9),(64,9),(66,5),(83,9),(112,9),
          (130,9),(165,9),(185,9)],
       p=[(28,3),(48,4),(92,3),(142,4),(175,2)],
       eg=[20,30,32,58,60,78,80,105,108,125,128,158,160,180,185],
       ek=[42,72,115,165],
       st=[(195,8,1)],
       f=205),

    # 3-3: Athletic
    _L(LT_ATHLETIC, 185,
       g=[(0,8),(170,184)],
       br=[(35,40,6),(65,70,4),(100,106,6),(135,140,4)],
       bi=[],
       q=[(20,8),(37,3),(67,7),(103,3),(137,8),(155,6)],
       p=[],
       eg=[22,40,72,108,140,158],
       ek=[55,88,120],
       st=[(162,8,1)],
       f=175,
       plat=[(10,11,5),(17,9,4),(24,7,3),(30,10,4),(35,5,7),
              (44,10,5),(50,8,4),(56,11,3),(62,6,4),(68,4,5),
              (76,10,4),(82,8,3),(88,6,5),(95,10,4),(100,5,8),
              (110,10,4),(116,8,3),(122,6,5),(128,10,4),(134,4,8),
              (144,10,4),(150,8,3),(156,6,5),(162,10,3)]),

    # 3-4: Castle
    _L(LT_CASTLE, 195,
       g=[(0,22),(26,52),(56,82),(86,130),(134,194)],
       br=[(5,12,5),(5,12,9),(30,40,5),(30,40,9),(62,72,5),
           (62,72,9),(92,105,5),(110,120,5),(140,152,5),(160,172,9)],
       bi=[(15,9),(45,9),(78,9),(108,9),(130,9)],
       q=[],
       p=[],
       eg=[12,15,35,38,65,68,95,98,115,118,145,148,165,168],
       ek=[],
       st=[(180,4,1)],
       f=190, ceil=True,
       lava=[(23,25),(53,55),(83,85),(131,133)]),

    # ===================== WORLD 4 =====================
    # 4-1: Overworld - long with many gaps
    _L(LT_OVER, 230,
       g=[(0,38),(41,68),(71,105),(108,148),(151,185),(188,229)],
       br=[(10,16,9),(30,35,5),(48,54,9),(75,82,9),(95,100,5),
           (115,122,9),(138,144,5),(158,164,9),(175,180,5),(200,206,9)],
       bi=[(18,5),(40,9),(58,5),(85,9),(105,5),(128,9),(148,5),(168,9)],
       q=[(12,9),(14,5),(32,9),(50,9),(52,5),(78,9),(80,5),
          (98,9),(118,9),(120,5),(140,9),(160,9),(178,9),(203,9)],
       p=[(20,3),(60,4),(88,3),(130,4),(170,3)],
       eg=[14,28,30,45,48,72,75,92,95,112,115,135,138,155,
           158,178,195,198,205,208],
       ek=[38,65,105,145,185],
       st=[(210,8,1)],
       f=220),

    # 4-2: Underground - maze-like
    _L(LT_UNDER, 215,
       g=[(0,30),(33,60),(63,98),(101,140),(143,175),(178,214)],
       br=[(5,12,5),(5,12,9),(20,28,5),(38,48,9),(38,48,5),
           (65,75,9),(65,75,5),(85,95,9),(85,95,5),(108,118,5),
           (125,135,9),(148,158,5),(165,172,9),(185,195,9)],
       bi=[(15,9),(32,5),(55,9),(78,5),(100,9),(120,5),(140,9),(162,5)],
       q=[(8,9),(10,5),(24,9),(42,9),(44,5),(70,9),(72,5),
          (90,9),(92,5),(112,9),(130,9),(152,9),(168,9),(190,9)],
       p=[(28,2),(52,3),(95,2),(138,3),(172,2)],
       eg=[12,25,28,42,45,68,72,88,92,110,115,128,132,150,155,168,188,192],
       ek=[35,58,82,122,160],
       st=[(198,8,1)],
       f=205, ceil=True),

    # 4-3: Athletic - high platforms
    _L(LT_ATHLETIC, 195,
       g=[(0,10),(180,194)],
       br=[(30,35,5),(60,66,7),(95,102,4),(130,136,6)],
       bi=[],
       q=[(18,8),(32,3),(62,4),(98,7),(132,3),(160,7)],
       p=[],
       eg=[20,35,68,105,138,162],
       ek=[50,82,118,150],
       st=[(172,8,1)],
       f=185,
       plat=[(12,11,5),(19,9,4),(26,7,3),(32,10,5),(38,5,6),
              (46,10,4),(52,8,5),(58,6,4),(64,8,6),(72,11,4),
              (78,9,3),(84,7,5),(90,5,4),(96,8,6),(104,10,4),
              (110,8,5),(116,6,3),(122,10,4),(128,5,7),(136,10,4),
              (142,8,5),(148,6,3),(154,10,4),(160,8,5),(168,11,4)]),

    # 4-4: Castle - firebars and lava
    _L(LT_CASTLE, 200,
       g=[(0,18),(22,48),(52,78),(82,118),(122,155),(159,199)],
       br=[(5,10,5),(5,10,9),(25,35,5),(25,35,9),(55,65,5),(55,65,9),
           (85,98,5),(85,98,9),(105,115,5),(128,140,5),(145,152,9),
           (165,178,5),(165,178,9)],
       bi=[(14,9),(40,9),(70,9),(100,9),(120,9),(155,9)],
       q=[],
       p=[],
       eg=[10,14,28,32,58,62,88,92,108,112,130,135,148,168,172],
       ek=[45,75],
       st=[(182,4,1)],
       f=192, ceil=True,
       lava=[(19,21),(49,51),(79,81),(119,121),(156,158)]),

    # ===================== WORLD 5 =====================
    # 5-1: Overworld - bullet bills and gaps
    _L(LT_OVER, 235,
       g=[(0,35),(38,65),(68,108),(111,152),(155,192),(195,234)],
       br=[(8,14,9),(25,32,5),(45,52,9),(72,80,9),(92,98,5),
           (115,122,9),(135,142,5),(158,165,9),(178,184,5),(205,212,9)],
       bi=[(16,5),(35,9),(55,5),(82,9),(100,5),(125,9),(148,5),(170,9),(188,5)],
       q=[(10,9),(12,5),(28,9),(48,9),(50,5),(75,9),(78,5),
          (95,9),(118,9),(120,5),(138,9),(162,9),(180,9),(208,9)],
       p=[(18,3),(56,4),(85,3),(128,4),(172,3),(192,2)],
       eg=[12,22,25,42,48,70,75,90,95,114,118,132,138,156,160,
           175,180,200,205,215,218],
       ek=[35,62,102,148,188],
       st=[(218,8,1)],
       f=225),

    # 5-2: Underground - long corridor
    _L(LT_UNDER, 220,
       g=[(0,28),(31,58),(61,95),(98,138),(141,178),(181,219)],
       br=[(5,14,5),(5,14,9),(22,28,5),(35,45,9),(35,45,5),
           (65,78,9),(65,78,5),(85,92,9),(102,115,5),(122,132,9),
           (145,155,5),(162,172,9),(185,198,9)],
       bi=[(16,9),(30,5),(50,9),(80,5),(96,9),(118,5),(138,9),(158,5),(175,9)],
       q=[(8,9),(10,5),(25,9),(40,9),(42,5),(70,9),(72,5),
          (88,9),(105,9),(108,5),(128,9),(148,9),(168,9),(192,9)],
       p=[(28,2),(55,3),(92,2),(135,3),(175,2)],
       eg=[10,15,25,38,42,65,70,85,88,105,110,125,130,148,152,165,188,195],
       ek=[48,78,115,155,178],
       st=[(202,8,1)],
       f=210, ceil=True),

    # 5-3: Athletic - cloud level
    _L(LT_ATHLETIC, 200,
       g=[(0,8),(185,199)],
       br=[(28,34,6),(55,62,4),(88,96,7),(125,132,5),(158,164,6)],
       bi=[],
       q=[(16,8),(30,3),(58,7),(92,4),(128,8),(160,3),(175,7)],
       p=[],
       eg=[18,35,62,98,132,165,178],
       ek=[48,75,110,145],
       st=[(178,8,1)],
       f=190,
       plat=[(10,11,6),(18,9,4),(25,7,5),(32,10,3),(38,5,7),
              (46,10,5),(52,8,4),(58,6,6),(66,10,4),(72,8,5),
              (78,6,3),(84,10,4),(90,5,7),(98,10,5),(104,8,4),
              (110,6,5),(116,10,3),(122,8,4),(128,5,7),(136,10,4),
              (142,8,5),(148,6,3),(154,10,4),(160,8,6),(168,11,4),
              (175,9,5)]),

    # 5-4: Castle
    _L(LT_CASTLE, 205,
       g=[(0,20),(24,50),(54,82),(86,120),(124,158),(162,204)],
       br=[(5,12,5),(5,12,9),(28,38,5),(28,38,9),(58,68,5),(58,68,9),
           (90,102,5),(90,102,9),(108,118,5),(130,142,5),(148,155,9),
           (168,182,5),(168,182,9)],
       bi=[(16,9),(42,9),(72,9),(105,9),(122,9),(158,9)],
       q=[],
       p=[],
       eg=[12,16,30,35,60,65,92,98,110,115,132,138,150,170,175,180],
       ek=[45,75,105],
       st=[(188,4,1)],
       f=198, ceil=True,
       lava=[(21,23),(51,53),(83,85),(121,123),(159,161)]),

    # ===================== WORLD 6 =====================
    # 6-1: Overworld - heavy enemy placement
    _L(LT_OVER, 240,
       g=[(0,32),(35,62),(65,105),(108,148),(151,195),(198,239)],
       br=[(8,16,9),(25,30,5),(40,48,9),(68,78,9),(88,95,5),
           (112,120,9),(132,140,5),(155,164,9),(178,185,5),(208,218,9)],
       bi=[(18,5),(32,9),(52,5),(80,9),(98,5),(122,9),(145,5),(168,9),(190,5)],
       q=[(10,9),(14,5),(28,9),(44,9),(46,5),(72,9),(75,5),
          (92,9),(115,9),(118,5),(135,9),(158,9),(162,5),(182,9),(212,9)],
       p=[(20,3),(55,4),(82,3),(125,4),(170,3),(195,2)],
       eg=[12,18,28,32,42,48,68,72,85,90,110,115,130,135,152,158,
           175,180,202,208,218,222],
       ek=[38,65,100,142,188,215],
       st=[(225,8,1)],
       f=232),

    # 6-2: Underground - complex layout
    _L(LT_UNDER, 225,
       g=[(0,25),(28,55),(58,92),(95,135),(138,178),(181,224)],
       br=[(5,15,5),(5,15,9),(20,25,5),(32,42,9),(32,42,5),
           (62,75,9),(62,75,5),(82,90,9),(100,112,5),(120,132,9),
           (142,155,5),(160,172,9),(185,200,9)],
       bi=[(18,9),(27,5),(48,9),(78,5),(94,9),(115,5),(136,9),(158,5),(175,9)],
       q=[(8,9),(12,5),(22,9),(36,9),(38,5),(68,9),(70,5),
          (85,9),(88,5),(105,9),(125,9),(148,9),(165,9),(192,9)],
       p=[(25,2),(50,3),(90,2),(132,3),(175,2)],
       eg=[10,18,22,35,40,65,70,82,88,102,108,122,128,145,152,162,
           168,188,195],
       ek=[45,75,112,158,180],
       st=[(205,8,1)],
       f=215, ceil=True),

    # 6-3: Athletic
    _L(LT_ATHLETIC, 200,
       g=[(0,8),(188,199)],
       br=[(25,32,5),(55,62,7),(88,98,4),(128,135,6),(160,168,5)],
       bi=[],
       q=[(15,8),(28,3),(58,4),(92,7),(130,3),(162,8),(180,6)],
       p=[],
       eg=[18,32,62,98,135,168,182],
       ek=[45,78,115,150],
       st=[(180,8,1)],
       f=192,
       plat=[(10,11,5),(17,9,4),(24,7,5),(30,5,6),(38,10,4),
              (44,8,5),(50,6,4),(56,8,7),(64,10,4),(70,8,5),
              (76,6,3),(82,10,5),(88,4,8),(98,10,4),(104,8,5),
              (110,6,3),(116,10,5),(122,5,6),(130,8,4),(136,10,5),
              (142,8,3),(148,6,5),(154,10,4),(160,5,8),(170,10,4),
              (176,8,5)]),

    # 6-4: Castle - long with many lava gaps
    _L(LT_CASTLE, 210,
       g=[(0,18),(22,45),(49,75),(79,115),(119,152),(156,180),(184,209)],
       br=[(5,12,5),(5,12,9),(25,35,5),(25,35,9),(52,62,5),(52,62,9),
           (82,95,5),(82,95,9),(105,112,5),(122,135,5),(140,148,9),
           (160,175,5),(160,175,9),(190,200,9)],
       bi=[(15,9),(38,9),(68,9),(98,9),(118,9),(152,9),(180,9)],
       q=[],
       p=[],
       eg=[10,15,28,32,55,60,85,90,108,112,125,130,142,162,168,175,192,198],
       ek=[42,72,100,148],
       st=[(200,4,1)],
       f=205, ceil=True,
       lava=[(19,21),(46,48),(76,78),(116,118),(153,155),(181,183)]),

    # ===================== WORLD 7 =====================
    # 7-1: Overworld - expert difficulty
    _L(LT_OVER, 245,
       g=[(0,28),(31,55),(58,92),(95,132),(135,175),(178,210),(213,244)],
       br=[(8,14,9),(22,28,5),(38,46,9),(62,72,9),(82,88,5),
           (100,108,9),(118,125,5),(140,148,9),(158,165,5),(182,190,9),
           (200,208,5),(220,228,9)],
       bi=[(16,5),(30,9),(48,5),(75,9),(92,5),(110,9),(130,5),(152,9),
           (168,5),(195,9),(212,5)],
       q=[(10,9),(12,5),(25,9),(42,9),(44,5),(66,9),(68,5),(85,9),
          (104,9),(106,5),(122,9),(144,9),(162,9),(185,9),(204,9),(224,9)],
       p=[(18,3),(50,4),(78,3),(112,4),(155,3),(198,2)],
       eg=[12,20,25,35,42,60,65,80,85,98,105,118,122,138,145,
           155,162,180,185,198,205,222,228],
       ek=[32,58,95,135,175,215],
       st=[(230,8,1)],
       f=238),

    # 7-2: Underground
    _L(LT_UNDER, 230,
       g=[(0,22),(25,52),(55,88),(91,130),(133,172),(175,229)],
       br=[(5,15,5),(5,15,9),(18,22,5),(30,42,9),(30,42,5),
           (58,72,9),(58,72,5),(80,88,9),(95,108,5),(115,128,9),
           (138,152,5),(158,168,9),(180,195,9),(205,215,5)],
       bi=[(16,9),(24,5),(48,9),(75,5),(90,9),(110,5),(132,9),(155,5),(172,9)],
       q=[(8,9),(12,5),(20,9),(35,9),(38,5),(62,9),(65,5),
          (82,9),(100,9),(105,5),(120,9),(142,9),(162,9),(185,9),(210,9)],
       p=[(22,2),(48,3),(88,2),(130,3),(170,2)],
       eg=[10,15,20,32,38,60,65,78,85,98,105,118,125,140,148,
           160,165,182,190,208,212],
       ek=[42,72,108,152,195],
       st=[(215,8,1)],
       f=222, ceil=True),

    # 7-3: Athletic
    _L(LT_ATHLETIC, 205,
       g=[(0,8),(192,204)],
       br=[(22,30,5),(52,60,7),(85,95,4),(122,130,6),(155,165,5)],
       bi=[],
       q=[(15,8),(25,3),(55,4),(88,7),(125,3),(158,8),(178,6)],
       p=[],
       eg=[18,30,60,95,130,165,180],
       ek=[42,72,108,145,172],
       st=[(185,8,1)],
       f=195,
       plat=[(10,11,5),(17,9,4),(23,7,3),(28,10,5),(34,5,6),
              (42,10,4),(48,8,5),(54,6,4),(60,8,7),(68,10,4),
              (74,8,5),(80,6,3),(86,4,6),(94,10,4),(100,8,5),
              (106,6,3),(112,10,5),(118,5,6),(124,8,5),(130,10,4),
              (136,8,3),(142,6,5),(148,10,4),(154,5,8),(162,10,4),
              (168,8,5),(174,6,3),(180,10,5)]),

    # 7-4: Castle - tricky
    _L(LT_CASTLE, 215,
       g=[(0,16),(20,42),(46,72),(76,110),(114,148),(152,180),(184,214)],
       br=[(5,10,5),(5,10,9),(22,32,5),(22,32,9),(48,58,5),(48,58,9),
           (78,92,5),(78,92,9),(100,108,5),(118,130,5),(135,145,9),
           (155,170,5),(155,170,9),(188,202,9)],
       bi=[(14,9),(36,9),(62,9),(95,9),(112,9),(148,9),(178,9)],
       q=[],
       p=[],
       eg=[8,14,25,30,50,55,80,85,102,108,120,125,138,158,165,172,192,198],
       ek=[38,68,95,142,175],
       st=[(205,4,1)],
       f=210, ceil=True,
       lava=[(17,19),(43,45),(73,75),(111,113),(149,151),(181,183)]),

    # ===================== WORLD 8 =====================
    # 8-1: Overworld - gauntlet
    _L(LT_OVER, 250,
       g=[(0,25),(28,48),(51,78),(81,115),(118,150),(153,188),(191,220),(223,249)],
       br=[(5,12,9),(18,24,5),(32,40,9),(55,65,9),(72,78,5),
           (85,95,9),(105,112,5),(122,130,9),(140,148,5),(158,168,9),
           (175,182,5),(195,205,9),(212,220,5),(228,238,9)],
       bi=[(14,5),(26,9),(42,5),(68,9),(80,5),(98,9),(115,5),(132,9),
           (150,5),(172,9),(188,5),(208,9),(222,5)],
       q=[(8,9),(10,5),(20,9),(36,9),(38,5),(60,9),(62,5),(75,9),
          (90,9),(92,5),(108,9),(125,9),(128,5),(145,9),(162,9),
          (178,9),(200,9),(215,9),(232,9)],
       p=[(15,3),(44,4),(70,3),(100,4),(135,3),(172,2),(210,3)],
       eg=[8,14,20,30,35,52,58,68,75,82,88,100,108,120,125,138,145,
           155,162,175,180,192,198,212,218,230,235],
       ek=[26,48,78,115,150,188,222],
       st=[(238,8,1)],
       f=245),

    # 8-2: Underground - final underground
    _L(LT_UNDER, 235,
       g=[(0,20),(23,48),(51,82),(85,122),(125,165),(168,200),(203,234)],
       br=[(5,14,5),(5,14,9),(16,20,5),(28,40,9),(28,40,5),
           (55,68,9),(55,68,5),(75,82,9),(90,105,5),(110,125,9),
           (130,145,5),(152,165,9),(172,185,9),(195,205,5),(210,222,9)],
       bi=[(15,9),(22,5),(45,9),(70,5),(84,9),(108,5),(128,9),(148,5),
           (168,9),(190,5),(205,9)],
       q=[(8,9),(12,5),(18,9),(32,9),(35,5),(60,9),(62,5),
          (78,9),(95,9),(98,5),(115,9),(135,9),(155,9),(178,9),(198,9),(215,9)],
       p=[(20,2),(45,3),(82,2),(122,3),(165,2),(200,3)],
       eg=[10,16,20,30,38,55,62,72,78,92,98,112,118,132,138,152,158,
           175,182,195,200,212,218],
       ek=[42,68,105,145,185,208],
       st=[(222,8,1)],
       f=228, ceil=True),

    # 8-3: Athletic - final athletic
    _L(LT_ATHLETIC, 210,
       g=[(0,8),(198,209)],
       br=[(20,28,5),(48,58,7),(82,92,4),(118,128,6),(152,162,5),(180,188,7)],
       bi=[],
       q=[(14,8),(24,3),(52,4),(86,7),(122,3),(156,8),(184,4)],
       p=[],
       eg=[16,28,58,92,128,162,188],
       ek=[40,70,108,142,172],
       st=[(192,8,1)],
       f=202,
       plat=[(10,11,5),(17,9,4),(23,7,3),(28,10,5),(34,5,6),
              (40,10,4),(46,8,5),(52,6,4),(58,8,8),(68,10,4),
              (74,8,5),(80,6,3),(86,4,6),(94,10,4),(100,8,5),
              (106,6,3),(112,10,5),(118,5,7),(126,10,4),(132,8,5),
              (138,6,3),(144,10,4),(150,5,8),(160,10,4),(166,8,5),
              (172,6,3),(178,10,4),(184,8,5),(192,11,4)]),

    # 8-4: Castle - FINAL LEVEL (Bowser's Castle)
    _L(LT_CASTLE, 250,
       g=[(0,15),(19,38),(42,65),(69,95),(99,128),(132,162),(166,198),(202,249)],
       br=[(5,10,5),(5,10,9),(22,30,5),(22,30,9),(45,55,5),(45,55,9),
           (72,82,5),(72,82,9),(102,115,5),(102,115,9),(120,128,5),
           (135,148,5),(135,148,9),(155,162,9),(170,185,5),(170,185,9),
           (195,198,5),(205,222,5),(205,222,9),(230,242,9)],
       bi=[(12,9),(34,9),(58,9),(85,9),(118,9),(130,9),(152,9),
           (165,9),(192,9),(200,9),(225,9)],
       q=[],
       p=[],
       eg=[8,12,25,30,48,52,75,80,105,110,122,128,138,145,158,
           172,178,185,195,208,215,222,235,240],
       ek=[35,62,88,115,148,165,198],
       st=[(242,4,1)],
       f=246, ceil=True,
       lava=[(16,18),(39,41),(66,68),(96,98),(129,131),(163,165),(199,201)]),
]

# ============================================================
# SOUND GENERATION (simple synth bleeps)
# ============================================================
def make_sound(freq, dur_ms, vol=0.3):
    sr = 22050
    n = int(sr * dur_ms / 1000)
    buf = bytearray(n * 2)
    for i in range(n):
        t = i / sr
        env = max(0, 1 - i / n)
        val = int(vol * env * 32767 * math.sin(2 * math.pi * freq * t))
        val = max(-32768, min(32767, val))
        buf[i*2] = val & 0xFF
        buf[i*2+1] = (val >> 8) & 0xFF
    snd = pygame.mixer.Sound(buffer=bytes(buf))
    return snd

SND_JUMP    = make_sound(600, 80)
SND_COIN    = make_sound(988, 60, 0.2)
SND_STOMP   = make_sound(200, 100)
SND_BRICK   = make_sound(150, 60)
SND_POWERUP = make_sound(1200, 150, 0.2)
SND_DIE     = make_sound(180, 400, 0.4)
SND_FLAG    = make_sound(800, 200, 0.3)
SND_1UP     = make_sound(1400, 120, 0.2)

# ============================================================
# SPRITE / DRAWING HELPERS
# ============================================================
def draw_rect(surf, color, x, y, w, h):
    pygame.draw.rect(surf, color, (int(x), int(y), int(w), int(h)))

def draw_mario(surf, x, y, big=False, star=False, fire=False, facing=1, frame=0):
    """Draw Mario sprite using rects (NES-style)."""
    s = SCALE
    if star:
        colors = [(C_STAR_Y, C_WHITE, C_MARIO_BROWN),
                  (C_MARIO_R, C_STAR_Y, C_WHITE),
                  (C_WHITE, C_MARIO_R, C_STAR_Y)]
        ci = (pygame.time.get_ticks() // 80) % 3
        hat, skin, shoes = colors[ci]
    elif fire:
        hat, skin, shoes = C_WHITE, C_MARIO_S, C_FIRE_R
    else:
        hat, skin, shoes = C_MARIO_R, C_MARIO_S, C_MARIO_BROWN

    if big:
        # Big Mario: 16x32
        h_off = -T
        # Hat
        draw_rect(surf, hat, x + 3*s, y + h_off, 10*s, 4*s)
        # Face
        draw_rect(surf, skin, x + 2*s, y + h_off + 4*s, 12*s, 5*s)
        # Eyes
        ex = x + 9*s if facing > 0 else x + 4*s
        draw_rect(surf, C_BLACK, ex, y + h_off + 5*s, 2*s, 2*s)
        # Body
        draw_rect(surf, hat, x + 2*s, y + h_off + 9*s, 12*s, 7*s)
        # Overalls
        draw_rect(surf, shoes, x + 2*s, y + h_off + 16*s, 12*s, 8*s)
        # Belt
        draw_rect(surf, C_BLACK, x + 4*s, y + h_off + 16*s, 8*s, 2*s)
        # Legs
        if frame % 2 == 1:
            draw_rect(surf, shoes, x + 1*s, y + h_off + 24*s, 5*s, 8*s)
            draw_rect(surf, shoes, x + 9*s, y + h_off + 24*s, 5*s, 8*s)
        else:
            draw_rect(surf, shoes, x + 2*s, y + h_off + 24*s, 5*s, 8*s)
            draw_rect(surf, shoes, x + 8*s, y + h_off + 24*s, 5*s, 8*s)
    else:
        # Small Mario: 16x16
        # Hat
        draw_rect(surf, hat, x + 3*s, y + 1*s, 10*s, 3*s)
        # Face
        draw_rect(surf, skin, x + 2*s, y + 4*s, 12*s, 4*s)
        # Eyes
        ex = x + 9*s if facing > 0 else x + 4*s
        draw_rect(surf, C_BLACK, ex, y + 5*s, 2*s, 2*s)
        # Body
        draw_rect(surf, hat, x + 3*s, y + 8*s, 10*s, 4*s)
        # Legs
        if frame % 2 == 1:
            draw_rect(surf, shoes, x + 2*s, y + 12*s, 5*s, 4*s)
            draw_rect(surf, shoes, x + 9*s, y + 12*s, 5*s, 4*s)
        else:
            draw_rect(surf, shoes, x + 3*s, y + 12*s, 4*s, 4*s)
            draw_rect(surf, shoes, x + 8*s, y + 12*s, 4*s, 4*s)

def draw_goomba(surf, x, y, frame=0):
    s = SCALE
    # Body
    draw_rect(surf, C_GOOMBA, x + 2*s, y + 2*s, 12*s, 10*s)
    # Head top
    draw_rect(surf, C_GOOMBA_L, x + 1*s, y + 0*s, 14*s, 4*s)
    # Eyes
    draw_rect(surf, C_WHITE, x + 3*s, y + 4*s, 3*s, 3*s)
    draw_rect(surf, C_WHITE, x + 10*s, y + 4*s, 3*s, 3*s)
    draw_rect(surf, C_BLACK, x + 4*s, y + 5*s, 2*s, 2*s)
    draw_rect(surf, C_BLACK, x + 11*s, y + 5*s, 2*s, 2*s)
    # Feet
    if frame % 2 == 0:
        draw_rect(surf, C_BLACK, x + 0*s, y + 12*s, 6*s, 4*s)
        draw_rect(surf, C_BLACK, x + 10*s, y + 12*s, 6*s, 4*s)
    else:
        draw_rect(surf, C_BLACK, x + 1*s, y + 12*s, 6*s, 4*s)
        draw_rect(surf, C_BLACK, x + 9*s, y + 12*s, 6*s, 4*s)

def draw_koopa(surf, x, y, frame=0):
    s = SCALE
    # Shell
    draw_rect(surf, C_KOOPA_G, x + 2*s, y + 4*s, 12*s, 8*s)
    draw_rect(surf, C_KOOPA_G, x + 4*s, y + 2*s, 8*s, 12*s)
    # Shell rim
    draw_rect(surf, C_KOOPA_S, x + 5*s, y + 6*s, 6*s, 4*s)
    # Head
    draw_rect(surf, C_KOOPA_S, x + 3*s, y + 0*s, 6*s, 5*s)
    # Eye
    draw_rect(surf, C_WHITE, x + 6*s, y + 1*s, 3*s, 3*s)
    draw_rect(surf, C_BLACK, x + 7*s, y + 2*s, 2*s, 2*s)
    # Feet
    if frame % 2 == 0:
        draw_rect(surf, C_KOOPA_S, x + 2*s, y + 13*s, 4*s, 3*s)
        draw_rect(surf, C_KOOPA_S, x + 10*s, y + 13*s, 4*s, 3*s)
    else:
        draw_rect(surf, C_KOOPA_S, x + 3*s, y + 13*s, 4*s, 3*s)
        draw_rect(surf, C_KOOPA_S, x + 9*s, y + 13*s, 4*s, 3*s)

def draw_tile_brick(surf, x, y, color):
    s = SCALE
    draw_rect(surf, color, x, y, T, T)
    # Mortar lines
    lc = tuple(max(0, c - 40) for c in color)
    pygame.draw.line(surf, lc, (int(x), int(y + T//2)), (int(x + T), int(y + T//2)))
    pygame.draw.line(surf, lc, (int(x + T//2), int(y)), (int(x + T//2), int(y + T//2)))
    pygame.draw.line(surf, lc, (int(x + T//4), int(y + T//2)), (int(x + T//4), int(y + T)))
    pygame.draw.line(surf, lc, (int(x + 3*T//4), int(y + T//2)), (int(x + 3*T//4), int(y + T)))

def draw_question_block(surf, x, y, hit=False):
    if hit:
        draw_rect(surf, C_GRAY, x, y, T, T)
        return
    s = SCALE
    fc = (pygame.time.get_ticks() // 200) % 4
    c = C_QUESTION if fc < 3 else (220, 130, 40)
    draw_rect(surf, c, x, y, T, T)
    # Question mark
    draw_rect(surf, C_QMARK, x + 5*s, y + 3*s, 6*s, 2*s)
    draw_rect(surf, C_QMARK, x + 9*s, y + 5*s, 2*s, 2*s)
    draw_rect(surf, C_QMARK, x + 6*s, y + 7*s, 4*s, 2*s)
    draw_rect(surf, C_QMARK, x + 7*s, y + 10*s, 2*s, 2*s)

def draw_pipe(surf, x, y, height):
    # Pipe body
    pw = T * 2
    ph = height * T
    draw_rect(surf, C_PIPE, x + 4, y + T, pw - 8, ph - T)
    draw_rect(surf, C_PIPE_D, x + pw - 12, y + T, 8, ph - T)
    # Lip
    draw_rect(surf, C_PIPE_LIP, x, y, pw, T)
    draw_rect(surf, C_PIPE_D, x + pw - 8, y, 8, T)

def draw_flag(surf, x, y_base):
    # Pole
    draw_rect(surf, C_GRAY, x + T//2 - 2, y_base - 10*T, 4, 10*T)
    # Ball on top
    pygame.draw.circle(surf, C_GRAY, (int(x + T//2), int(y_base - 10*T)), 6)
    # Flag
    pts = [(x + T//2, y_base - 9*T), (x + T//2 + T, y_base - 8*T),
           (x + T//2, y_base - 7*T)]
    pygame.draw.polygon(surf, C_FLAG_G, [(int(a), int(b)) for a, b in pts])

def draw_castle(surf, x, y):
    s = SCALE
    # Main body
    w, h = T * 5, T * 4
    draw_rect(surf, C_CASTLE_W, x, y, w, h)
    # Door
    draw_rect(surf, C_BLACK, x + w//2 - T//2, y + h - T*2, T, T*2)
    # Battlement
    for i in range(5):
        draw_rect(surf, C_CASTLE_W, x + i * T, y - T, T - 4, T)
    # Window
    draw_rect(surf, C_BLACK, x + T, y + T//2, T//2, T//2)
    draw_rect(surf, C_BLACK, x + 3*T, y + T//2, T//2, T//2)

def draw_cloud(surf, x, y):
    s = SCALE
    pygame.draw.ellipse(surf, C_CLOUD, (int(x), int(y), T*2, T))
    pygame.draw.ellipse(surf, C_CLOUD, (int(x + T//2), int(y - T//3), T, T))

def draw_bush(surf, x, y):
    pygame.draw.ellipse(surf, C_BUSH, (int(x), int(y), T*3, T))
    pygame.draw.ellipse(surf, C_BUSH, (int(x + T//2), int(y - T//4), T*2, T))

def draw_hill(surf, x, y, w):
    pts = [(x, y + T), (x + w//2, y - T), (x + w, y + T)]
    pygame.draw.polygon(surf, C_HILL, [(int(a), int(b)) for a, b in pts])

# ============================================================
# PARTICLE SYSTEM
# ============================================================
class Particle:
    def __init__(self, x, y, vx, vy, color, life=30):
        self.x, self.y = x, y
        self.vx, self.vy = vx, vy
        self.color = color
        self.life = life
        self.max_life = life

    def update(self):
        self.x += self.vx
        self.y += self.vy
        self.vy += 0.3
        self.life -= 1
        return self.life > 0

    def draw(self, surf, cam_x):
        alpha = self.life / self.max_life
        sz = max(2, int(6 * alpha * SCALE))
        draw_rect(surf, self.color, self.x - cam_x, self.y, sz, sz)

# ============================================================
# COIN ANIMATION
# ============================================================
class CoinPopup:
    def __init__(self, x, y):
        self.x, self.y = x, y
        self.vy = -8
        self.life = 30

    def update(self):
        self.y += self.vy
        self.vy += 0.4
        self.life -= 1
        return self.life > 0

    def draw(self, surf, cam_x):
        s = SCALE
        sx = self.x - cam_x
        draw_rect(surf, C_COIN, sx + 4*s, self.y + 2*s, 8*s, 12*s)
        draw_rect(surf, (220, 180, 40), sx + 6*s, self.y + 4*s, 4*s, 8*s)

# ============================================================
# FIREBALL
# ============================================================
class Fireball:
    def __init__(self, x, y, direction):
        self.x, self.y = x, y
        self.vx = FIREBALL_SPD * direction
        self.vy = 0
        self.life = 180

    def update(self, solids):
        self.vy += GRAVITY * 0.5
        self.x += self.vx
        self.y += self.vy
        self.life -= 1

        # Bounce off ground
        r = pygame.Rect(self.x, self.y, T//2, T//2)
        for s in solids:
            if r.colliderect(s) and self.vy > 0:
                self.y = s.top - T//2
                self.vy = -4
                break

        return self.life > 0 and self.y < SCR_H + 100

    def draw(self, surf, cam_x):
        fc = (pygame.time.get_ticks() // 50) % 2
        c = C_FIRE_R if fc == 0 else C_FIRE_O
        sx = self.x - cam_x
        pygame.draw.circle(surf, c, (int(sx + T//4), int(self.y + T//4)), int(T//3))

    def get_rect(self):
        return pygame.Rect(self.x, self.y, T//2, T//2)

# ============================================================
# GAME STATE
# ============================================================
class Game:
    def __init__(self):
        self.state = 'menu'  # menu, play, gameover, win
        self.lives = 3
        self.score = 0
        self.coins = 0
        self.world = 0  # 0-31 (level index)
        self.time_left = 400
        self.font = pygame.font.Font(None, int(24 * SCALE / 2))
        self.small_font = pygame.font.Font(None, int(18 * SCALE / 2))
        self.menu_sel = 0
        self.reset_level()

    def reset_level(self):
        ld = LEVELS[self.world]
        self.level = ld
        self.cam_x = 0
        self.time_left = 400

        # Mario state
        self.mx = 3 * T
        self.my = 0
        self.mvx = 0
        self.mvy = 0
        self.on_ground = False
        self.facing = 1
        self.big = False
        self.has_star = False
        self.has_fire = False
        self.star_timer = 0
        self.invuln = 0
        self.anim_frame = 0
        self.anim_timer = 0
        self.dead = False
        self.death_timer = 0
        self.win_flag = False
        self.win_timer = 0

        # Question block / brick tracking (must init before build_level)
        self.hit_questions = set()
        self.hit_bricks = set()

        # Effects
        self.particles = []
        self.coin_popups = []
        self.fireballs = []

        # Build solid tiles
        self.build_level()

        # Spawn enemies
        self.enemies = []
        ground_y = 13 * T
        for col in ld['eg']:
            self.enemies.append({
                'type': 'goomba', 'x': col * T, 'y': ground_y - T,
                'vx': -ENEMY_SPD, 'vy': 0, 'alive': True, 'squish': 0,
                'on_ground': False, 'frame': 0
            })
        for col in ld['ek']:
            self.enemies.append({
                'type': 'koopa', 'x': col * T, 'y': ground_y - T * 1.5,
                'vx': -ENEMY_SPD, 'vy': 0, 'alive': True, 'shell': False,
                'shell_moving': False, 'on_ground': False, 'frame': 0
            })

    def build_level(self):
        ld = self.level
        self.solids = []
        self.ground_rects = []
        self.brick_rects = []
        self.question_rects = []
        self.pipe_data = []
        self.stair_rects = []
        self.plat_rects = []
        self.lava_rects = []

        row_ground = 13  # ground is at row 13 (of 15)
        row_bottom = 15

        # Ground segments
        for seg in ld['g']:
            s, e = seg
            r = pygame.Rect(s * T, row_ground * T, (e - s + 1) * T, (row_bottom - row_ground) * T)
            self.ground_rects.append(r)
            self.solids.append(r)

        # Brick rows
        for br in ld['br']:
            sc, ec, row = br
            for c in range(sc, ec + 1):
                key = (c, row)
                if key not in self.hit_bricks:
                    r = pygame.Rect(c * T, row * T, T, T)
                    self.brick_rects.append((r, key))
                    self.solids.append(r)

        # Individual bricks
        for bi in ld['bi']:
            c, row = bi
            key = (c, row)
            if key not in self.hit_bricks:
                r = pygame.Rect(c * T, row * T, T, T)
                self.brick_rects.append((r, key))
                self.solids.append(r)

        # Question blocks
        for q in ld['q']:
            c, row = q
            key = (c, row)
            r = pygame.Rect(c * T, row * T, T, T)
            self.question_rects.append((r, key))
            self.solids.append(r)

        # Pipes
        for p in ld['p']:
            c, h = p
            py = row_ground * T - h * T
            pw = T * 2
            ph = h * T
            r = pygame.Rect(c * T, py, pw, ph)
            self.pipe_data.append((c, h, r))
            self.solids.append(r)

        # Stairs
        for st in ld['st']:
            c, h, d = st
            for step in range(h):
                if d == 1:
                    sc = c + step
                    sh = step + 1
                else:
                    sc = c + h - 1 - step
                    sh = step + 1
                for sy in range(sh):
                    r = pygame.Rect(sc * T, (row_ground - sh + sy) * T, T, T)
                    self.stair_rects.append(r)
                    self.solids.append(r)

        # Platforms (athletic levels)
        for pl in ld['plat']:
            c, row, w = pl
            r = pygame.Rect(c * T, row * T, w * T, T // 2)
            self.plat_rects.append(r)
            self.solids.append(r)

        # Lava (castle levels)
        for lv in ld['lava']:
            s, e = lv
            r = pygame.Rect(s * T, row_ground * T - T//4, (e - s + 1) * T, T * 2)
            self.lava_rects.append(r)

        # Ceiling
        if ld['ceil']:
            self.ceil_rect = pygame.Rect(0, 0, ld['w'] * T, T)
            self.solids.append(self.ceil_rect)
        else:
            self.ceil_rect = None

    def get_world_name(self):
        w = self.world // 4 + 1
        l = self.world % 4 + 1
        return f"{w}-{l}"

    def update_menu(self, keys_pressed, keys_just):
        if keys_just.get(pygame.K_UP) or keys_just.get(pygame.K_w):
            self.menu_sel = (self.menu_sel - 1) % 2
        if keys_just.get(pygame.K_DOWN) or keys_just.get(pygame.K_s):
            self.menu_sel = (self.menu_sel + 1) % 2
        if keys_just.get(pygame.K_RETURN) or keys_just.get(pygame.K_z) or keys_just.get(pygame.K_SPACE):
            if self.menu_sel == 0:
                self.state = 'play'
                self.lives = 3
                self.score = 0
                self.coins = 0
                self.world = 0
                self.reset_level()
            else:
                pygame.quit()
                sys.exit()

    def draw_menu(self):
        screen.fill(C_MENU_BG)
        # Title
        title = self.font.render("ULTRA MARIO 2D BROS", True, C_TITLE)
        screen.blit(title, (SCR_W // 2 - title.get_width() // 2, SCR_H // 4))

        sub = self.small_font.render("Team Flames / Samsoft", True, C_GRAY)
        screen.blit(sub, (SCR_W // 2 - sub.get_width() // 2, SCR_H // 4 + 50))

        # Draw small Mario
        draw_mario(screen, SCR_W // 2 - T // 2, SCR_H // 2 - T * 2)

        items = ["START GAME", "QUIT"]
        for i, item in enumerate(items):
            c = C_SEL if i == self.menu_sel else C_UNSEL
            txt = self.font.render(item, True, c)
            y = SCR_H // 2 + i * 50
            screen.blit(txt, (SCR_W // 2 - txt.get_width() // 2, y))
            if i == self.menu_sel:
                draw_rect(screen, C_MARIO_R, SCR_W // 2 - txt.get_width() // 2 - 30, y + 5, 15, 15)

        ctrl = self.small_font.render("Arrow Keys/WASD: Move  |  Z/Space: Jump  |  X: Run/Fire", True, C_GRAY)
        screen.blit(ctrl, (SCR_W // 2 - ctrl.get_width() // 2, SCR_H - 80))

    def update_play(self, keys_pressed, keys_just, dt):
        if self.dead:
            self.death_timer -= 1
            self.mvy += GRAVITY * 0.5
            self.my += self.mvy
            if self.death_timer <= 0:
                self.lives -= 1
                if self.lives <= 0:
                    self.state = 'gameover'
                else:
                    self.reset_level()
            return

        if self.win_flag:
            self.win_timer -= 1
            # Slide down flagpole
            if self.my < 13 * T - T:
                self.my += 3
            if self.win_timer <= 0:
                self.world += 1
                if self.world >= len(LEVELS):
                    self.state = 'win'
                else:
                    self.reset_level()
            return

        # Timer
        if self.time_left > 0:
            self.time_left -= dt * 0.6
        if self.time_left <= 0:
            self.kill_mario()
            return

        # Star timer
        if self.has_star:
            self.star_timer -= 1
            if self.star_timer <= 0:
                self.has_star = False

        # Invulnerability
        if self.invuln > 0:
            self.invuln -= 1

        # Running
        run = keys_pressed[pygame.K_x] or keys_pressed[pygame.K_LSHIFT]
        max_spd = RUN_SPD if run else MAX_SPD

        # Horizontal movement
        if keys_pressed[pygame.K_LEFT] or keys_pressed[pygame.K_a]:
            self.mvx -= ACCEL
            self.facing = -1
        elif keys_pressed[pygame.K_RIGHT] or keys_pressed[pygame.K_d]:
            self.mvx += ACCEL
            self.facing = 1
        else:
            self.mvx *= FRICTION

        self.mvx = max(-max_spd, min(max_spd, self.mvx))

        # Jump
        if (keys_just.get(pygame.K_z) or keys_just.get(pygame.K_SPACE) or
            keys_just.get(pygame.K_UP) or keys_just.get(pygame.K_w)):
            if self.on_ground:
                self.mvy = JUMP
                self.on_ground = False
                SND_JUMP.play()

        # Variable jump height
        if not (keys_pressed[pygame.K_z] or keys_pressed[pygame.K_SPACE] or
                keys_pressed[pygame.K_UP] or keys_pressed[pygame.K_w]):
            if self.mvy < -3:
                self.mvy = -3

        # Fire
        if keys_just.get(pygame.K_x) and self.has_fire and len(self.fireballs) < 2:
            self.fireballs.append(Fireball(self.mx + T//2, self.my + T//3, self.facing))

        # Gravity
        self.mvy += GRAVITY

        # Move X
        self.mx += self.mvx
        mr = self.get_mario_rect()
        for s in self.solids:
            if mr.colliderect(s):
                if self.mvx > 0:
                    self.mx = s.left - mr.width
                elif self.mvx < 0:
                    self.mx = s.right
                self.mvx = 0
                mr = self.get_mario_rect()

        # Move Y
        self.my += self.mvy
        self.on_ground = False
        mr = self.get_mario_rect()
        for s in self.solids:
            if mr.colliderect(s):
                if self.mvy > 0:
                    self.my = s.top - mr.height
                    self.mvy = 0
                    self.on_ground = True
                elif self.mvy < 0:
                    self.my = s.bottom
                    self.mvy = 0
                    # Check if hit question or brick
                    self.hit_block_above(s)
                mr = self.get_mario_rect()

        # Fall death
        if self.my > 15 * T + T:
            self.kill_mario()
            return

        # Lava check
        mr = self.get_mario_rect()
        for lv in self.lava_rects:
            if mr.colliderect(lv):
                self.kill_mario()
                return

        # Animation
        self.anim_timer += abs(self.mvx)
        if self.anim_timer > 5:
            self.anim_timer = 0
            self.anim_frame += 1

        # Enemy collision
        mr = self.get_mario_rect()
        for e in self.enemies:
            if not e['alive']:
                continue
            if e.get('squish', 0) > 0:
                continue

            er = pygame.Rect(e['x'], e['y'], T, T)
            if not mr.colliderect(er):
                continue

            if e['type'] == 'koopa' and e.get('shell') and not e.get('shell_moving'):
                # Kick shell
                e['shell_moving'] = True
                e['vx'] = 5 if self.mx < e['x'] else -5
                SND_STOMP.play()
                self.score += 100
                continue

            if self.has_star:
                e['alive'] = False
                SND_STOMP.play()
                self.score += 200
                self.spawn_particles(e['x'], e['y'], C_STAR_Y)
                continue

            if self.mvy > 0 and mr.bottom - er.top < T // 2 + 4:
                # Stomp
                self.mvy = BOUNCE
                SND_STOMP.play()
                self.score += 100
                if e['type'] == 'goomba':
                    e['squish'] = 30
                    e['alive'] = True
                elif e['type'] == 'koopa':
                    if e.get('shell'):
                        e['shell_moving'] = not e['shell_moving']
                        if e['shell_moving']:
                            e['vx'] = 5 if self.mx < e['x'] else -5
                    else:
                        e['shell'] = True
                        e['vx'] = 0
            else:
                # Take damage
                if self.invuln <= 0:
                    if self.big:
                        self.big = False
                        self.has_fire = False
                        self.invuln = 90
                    else:
                        self.kill_mario()

        # Update enemies
        self.update_enemies()

        # Update fireballs
        for fb in self.fireballs[:]:
            if not fb.update(self.solids):
                self.fireballs.remove(fb)
                continue
            # Check enemy hit
            fr = fb.get_rect()
            for e in self.enemies:
                if e['alive'] and e.get('squish', 0) <= 0:
                    er = pygame.Rect(e['x'], e['y'], T, T)
                    if fr.colliderect(er):
                        e['alive'] = False
                        self.score += 200
                        SND_STOMP.play()
                        self.spawn_particles(e['x'], e['y'], C_FIRE_O)
                        if fb in self.fireballs:
                            self.fireballs.remove(fb)
                        break

        # Update particles
        self.particles = [p for p in self.particles if p.update()]
        self.coin_popups = [c for c in self.coin_popups if c.update()]

        # Flag check
        flag_col = self.level['f']
        if self.mx + T > flag_col * T and not self.win_flag:
            self.win_flag = True
            self.win_timer = 120
            self.mvx = 0
            self.score += max(0, int(self.time_left)) * 10
            SND_FLAG.play()

        # Camera
        target_cam = self.mx - SCR_W // 3
        self.cam_x = max(0, min(target_cam, (self.level['w'] - 16) * T))

    def get_mario_rect(self):
        if self.big:
            return pygame.Rect(self.mx + 4, self.my - T, T - 8, T * 2)
        return pygame.Rect(self.mx + 4, self.my, T - 8, T)

    def hit_block_above(self, solid):
        # Question blocks
        for r, key in self.question_rects:
            if r == solid and key not in self.hit_questions:
                self.hit_questions.add(key)
                self.coins += 1
                self.score += 200
                SND_COIN.play()
                self.coin_popups.append(CoinPopup(r.x, r.y - T))
                # Random powerup
                if random.random() < 0.25:
                    if not self.big:
                        self.big = True
                        SND_POWERUP.play()
                    elif not self.has_fire:
                        self.has_fire = True
                        SND_POWERUP.play()
                    elif random.random() < 0.3:
                        self.has_star = True
                        self.star_timer = 600
                        SND_POWERUP.play()
                return

        # Bricks
        if self.big:
            for r, key in self.brick_rects:
                if r == solid and key not in self.hit_bricks:
                    self.hit_bricks.add(key)
                    if r in self.solids:
                        self.solids.remove(r)
                    self.score += 50
                    SND_BRICK.play()
                    self.spawn_particles(r.x, r.y, C_BRICK)
                    return

    def kill_mario(self):
        self.dead = True
        self.death_timer = 60
        self.mvy = JUMP * 0.8
        self.mvx = 0
        SND_DIE.play()

    def update_enemies(self):
        for e in self.enemies:
            if not e['alive']:
                continue
            if e.get('squish', 0) > 0:
                e['squish'] -= 1
                if e['squish'] <= 0:
                    e['alive'] = False
                continue

            # Gravity
            e['vy'] = e.get('vy', 0) + GRAVITY
            e['x'] += e['vx']
            e['y'] += e['vy']

            # Ground collision
            er = pygame.Rect(e['x'], e['y'], T, T)
            e['on_ground'] = False
            for s in self.solids:
                if er.colliderect(s):
                    if e['vy'] > 0:
                        e['y'] = s.top - T
                        e['vy'] = 0
                        e['on_ground'] = True
                    er = pygame.Rect(e['x'], e['y'], T, T)

            # Wall collision
            er = pygame.Rect(e['x'], e['y'], T, T)
            for s in self.solids:
                if er.colliderect(s) and abs(e['vy']) < 1:
                    if e['vx'] > 0:
                        e['x'] = s.left - T
                    elif e['vx'] < 0:
                        e['x'] = s.right
                    e['vx'] *= -1
                    break

            # Fall off screen
            if e['y'] > 16 * T:
                e['alive'] = False

            # Animation
            e['frame'] = e.get('frame', 0)
            if pygame.time.get_ticks() % 300 < 16:
                e['frame'] += 1

            # Moving shell kills other enemies
            if e['type'] == 'koopa' and e.get('shell_moving'):
                for other in self.enemies:
                    if other is e or not other['alive']:
                        continue
                    if other.get('squish', 0) > 0:
                        continue
                    or2 = pygame.Rect(other['x'], other['y'], T, T)
                    if er.colliderect(or2):
                        other['alive'] = False
                        self.score += 200
                        SND_STOMP.play()

    def spawn_particles(self, x, y, color):
        for _ in range(6):
            vx = random.uniform(-3, 3)
            vy = random.uniform(-6, -1)
            self.particles.append(Particle(x + T//2, y + T//2, vx, vy, color))

    def draw_play(self):
        ld = self.level
        lt = ld['t']

        # Background
        if lt == LT_OVER:
            screen.fill(C_SKY)
        elif lt == LT_UNDER:
            screen.fill(C_UNDER_BG)
        elif lt == LT_ATHLETIC:
            screen.fill(C_ATH_BG)
        elif lt == LT_CASTLE:
            screen.fill(C_CASTLE_BG)

        cx = self.cam_x

        # Decorations (overworld / athletic)
        if lt in (LT_OVER, LT_ATHLETIC):
            # Clouds
            for i in range(0, ld['w'] * T, T * 20):
                x = i - cx * 0.3
                if -T * 3 < x < SCR_W + T:
                    draw_cloud(screen, x, T * 2 + (i % 7) * T // 2)
            # Bushes
            if lt == LT_OVER:
                for i in range(0, ld['w'] * T, T * 14):
                    x = i - cx
                    if -T * 4 < x < SCR_W + T:
                        draw_bush(screen, x, 13 * T - T // 2)

        # Lava animation
        for lv in self.lava_rects:
            sx = lv.x - cx
            fc = (pygame.time.get_ticks() // 200) % 2
            c = C_LAVA if fc == 0 else C_LAVA2
            draw_rect(screen, c, sx, lv.y, lv.width, lv.height)
            # Lava bubbles
            for bx in range(0, lv.width, T):
                if (bx + pygame.time.get_ticks() // 100) % 5 == 0:
                    pygame.draw.circle(screen, C_LAVA2,
                        (int(sx + bx + T//2), int(lv.y - 4)), 4)

        # Ground
        for r in self.ground_rects:
            sx = r.x - cx
            if sx + r.width < 0 or sx > SCR_W:
                continue
            gc = C_GROUND if lt in (LT_OVER, LT_ATHLETIC) else (
                 C_GROUND2 if lt == LT_UNDER else C_CBRICK)
            # Top layer
            draw_rect(screen, gc, sx, r.y, r.width, T)
            # Sub layer
            gc2 = tuple(max(0, c - 30) for c in gc)
            draw_rect(screen, gc2, sx, r.y + T, r.width, r.height - T)

        # Bricks
        for r, key in self.brick_rects:
            if key in self.hit_bricks:
                continue
            sx = r.x - cx
            if -T < sx < SCR_W + T:
                bc = C_BRICK if lt == LT_OVER else (
                     C_UBRICK if lt == LT_UNDER else (
                     C_CBRICK if lt == LT_CASTLE else C_BRICK))
                draw_tile_brick(screen, sx, r.y, bc)

        # Question blocks
        for r, key in self.question_rects:
            sx = r.x - cx
            if -T < sx < SCR_W + T:
                draw_question_block(screen, sx, r.y, key in self.hit_questions)

        # Stairs
        for r in self.stair_rects:
            sx = r.x - cx
            if -T < sx < SCR_W + T:
                sc = C_GROUND if lt in (LT_OVER, LT_ATHLETIC) else (
                     C_GROUND2 if lt == LT_UNDER else C_CBRICK)
                draw_rect(screen, sc, sx, r.y, T, T)
                draw_rect(screen, tuple(max(0, c - 20) for c in sc),
                         sx + 2, r.y + 2, T - 4, T - 4)

        # Platforms
        for r in self.plat_rects:
            sx = r.x - cx
            if -T < sx < SCR_W + T:
                draw_rect(screen, C_GROUND, sx, r.y, r.width, r.height)
                draw_rect(screen, tuple(max(0, c - 30) for c in C_GROUND),
                         sx + 2, r.y + 2, r.width - 4, r.height - 4)

        # Pipes
        for c, h, r in self.pipe_data:
            sx = c * T - cx
            if -T * 3 < sx < SCR_W + T:
                py = 13 * T - h * T
                draw_pipe(screen, sx, py, h)

        # Flag
        flag_col = ld['f']
        fx = flag_col * T - cx
        if -T * 2 < fx < SCR_W + T * 2:
            draw_flag(screen, fx, 13 * T)

        # Castle at end
        castle_x = (ld['f'] + 5) * T - cx
        if -T * 6 < castle_x < SCR_W + T:
            draw_castle(screen, castle_x, 13 * T - 4 * T)

        # Ceiling
        if ld['ceil']:
            draw_rect(screen, C_CBRICK if lt == LT_CASTLE else C_UBRICK,
                     0 - cx, 0, ld['w'] * T, T)

        # Enemies
        for e in self.enemies:
            if not e['alive'] and e.get('squish', 0) <= 0:
                continue
            sx = e['x'] - cx
            if sx < -T * 2 or sx > SCR_W + T * 2:
                continue
            if e['type'] == 'goomba':
                if e.get('squish', 0) > 0:
                    draw_rect(screen, C_GOOMBA, sx, e['y'] + T//2, T, T//2)
                else:
                    draw_goomba(screen, sx, e['y'], e.get('frame', 0))
            elif e['type'] == 'koopa':
                if e.get('shell'):
                    draw_rect(screen, C_KOOPA_G, sx + 2*SCALE, e['y'] + 2*SCALE,
                             12*SCALE, 12*SCALE)
                    draw_rect(screen, C_KOOPA_S, sx + 5*SCALE, e['y'] + 4*SCALE,
                             6*SCALE, 6*SCALE)
                else:
                    draw_koopa(screen, sx, e['y'], e.get('frame', 0))

        # Fireballs
        for fb in self.fireballs:
            fb.draw(screen, cx)

        # Coin popups
        for cp in self.coin_popups:
            cp.draw(screen, cx)

        # Particles
        for p in self.particles:
            p.draw(screen, cx)

        # Mario
        if not self.dead or self.death_timer > 0:
            sx = self.mx - cx
            visible = True
            if self.invuln > 0:
                visible = (self.invuln // 3) % 2 == 0
            if visible:
                draw_mario(screen, sx, self.my, self.big, self.has_star,
                          self.has_fire, self.facing, self.anim_frame)

        # HUD
        self.draw_hud()

    def draw_hud(self):
        y = 8
        # World
        wn = self.get_world_name()
        txt = self.font.render(f"WORLD {wn}", True, C_HUD)
        screen.blit(txt, (20, y))

        # Score
        txt = self.font.render(f"SCORE {self.score:06d}", True, C_HUD)
        screen.blit(txt, (SCR_W // 3, y))

        # Coins
        txt = self.font.render(f"x{self.coins:02d}", True, C_COIN)
        screen.blit(txt, (SCR_W * 2 // 3, y))

        # Time
        txt = self.font.render(f"TIME {max(0,int(self.time_left)):03d}", True, C_HUD)
        screen.blit(txt, (SCR_W - 180, y))

        # Lives
        txt = self.small_font.render(f"LIVES: {self.lives}", True, C_HUD)
        screen.blit(txt, (20, y + 30))

        # Powerup indicator
        if self.has_star:
            txt = self.small_font.render("★ STAR", True, C_STAR_Y)
            screen.blit(txt, (SCR_W // 2 - 40, y + 30))
        elif self.has_fire:
            txt = self.small_font.render("🔥 FIRE", True, C_FIRE_R)
            screen.blit(txt, (SCR_W // 2 - 40, y + 30))
        elif self.big:
            txt = self.small_font.render("▲ BIG", True, C_WHITE)
            screen.blit(txt, (SCR_W // 2 - 40, y + 30))

    def draw_gameover(self):
        screen.fill(C_BLACK)
        txt = self.font.render("GAME OVER", True, C_MARIO_R)
        screen.blit(txt, (SCR_W // 2 - txt.get_width() // 2, SCR_H // 3))
        txt2 = self.font.render(f"FINAL SCORE: {self.score:06d}", True, C_WHITE)
        screen.blit(txt2, (SCR_W // 2 - txt2.get_width() // 2, SCR_H // 2))
        txt3 = self.small_font.render("Press ENTER to return to menu", True, C_GRAY)
        screen.blit(txt3, (SCR_W // 2 - txt3.get_width() // 2, SCR_H * 2 // 3))

    def draw_win(self):
        screen.fill(C_BLACK)
        txt = self.font.render("CONGRATULATIONS!", True, C_STAR_Y)
        screen.blit(txt, (SCR_W // 2 - txt.get_width() // 2, SCR_H // 4))
        txt2 = self.font.render("YOU SAVED THE PRINCESS!", True, C_WHITE)
        screen.blit(txt2, (SCR_W // 2 - txt2.get_width() // 2, SCR_H // 3))
        txt3 = self.font.render(f"FINAL SCORE: {self.score:06d}", True, C_COIN)
        screen.blit(txt3, (SCR_W // 2 - txt3.get_width() // 2, SCR_H // 2))

        # Draw big Mario and castle
        draw_mario(screen, SCR_W // 2 - T * 2, SCR_H * 2 // 3 - T, big=True)
        draw_castle(screen, SCR_W // 2 + T, SCR_H * 2 // 3 - T * 3)

        txt4 = self.small_font.render("Press ENTER to return to menu", True, C_GRAY)
        screen.blit(txt4, (SCR_W // 2 - txt4.get_width() // 2, SCR_H - 60))

# ============================================================
# MAIN LOOP
# ============================================================
def main():
    game = Game()
    prev_keys = set()

    while True:
        dt = clock.tick(FPS) / 1000.0

        # Events
        for ev in pygame.event.get():
            if ev.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        keys = pygame.key.get_pressed()
        curr_keys = set(k for k in range(512) if keys[k])
        keys_just = {k: True for k in curr_keys - prev_keys}
        prev_keys = curr_keys

        # ESC to quit
        if keys_just.get(pygame.K_ESCAPE):
            if game.state == 'play':
                game.state = 'menu'
            else:
                pygame.quit()
                sys.exit()

        # State machine
        if game.state == 'menu':
            game.update_menu(keys, keys_just)
            game.draw_menu()
        elif game.state == 'play':
            game.update_play(keys, keys_just, dt)
            game.draw_play()
        elif game.state == 'gameover':
            game.draw_gameover()
            if keys_just.get(pygame.K_RETURN):
                game.state = 'menu'
        elif game.state == 'win':
            game.draw_win()
            if keys_just.get(pygame.K_RETURN):
                game.state = 'menu'

        pygame.display.flip()

if __name__ == '__main__':
    main()
